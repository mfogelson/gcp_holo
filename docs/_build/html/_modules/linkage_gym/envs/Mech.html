<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>linkage_gym.envs.Mech &mdash; GCP-HOLO 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> GCP-HOLO
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../train.html">Train</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mech.html">Mech Gym Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../linkage_gym.utils.html">Environment Utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">Utility Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gradio.html">Gradio Interface</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">GCP-HOLO</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>linkage_gym.envs.Mech</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for linkage_gym.envs.Mech</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">pdb</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">product</span>

<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="n">mpl</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;Agg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.patheffects</span> <span class="k">as</span> <span class="nn">pe</span>
<span class="kn">from</span> <span class="nn">matplotlib.offsetbox</span> <span class="kn">import</span> <span class="n">AnchoredText</span>

<span class="kn">import</span> <span class="nn">gym</span>
<span class="kn">from</span> <span class="nn">gym</span> <span class="kn">import</span> <span class="n">spaces</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">MT19937</span><span class="p">,</span> <span class="n">RandomState</span><span class="p">,</span> <span class="n">SeedSequence</span>

<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;..&#39;</span><span class="p">))</span>
<span class="kn">from</span> <span class="nn">linkage_gym.utils.env_utils</span> <span class="kn">import</span> <span class="n">distance</span><span class="p">,</span> <span class="n">normalize_curve</span><span class="p">,</span> <span class="n">symbolic_kinematics</span>


<div class="viewcode-block" id="Mech"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech">[docs]</a><span class="k">class</span> <span class="nc">Mech</span><span class="p">(</span><span class="n">gym</span><span class="o">.</span><span class="n">Env</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Custom Environment that follows gym interface&quot;&quot;&quot;</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;render_modes&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;human&quot;</span><span class="p">,</span> <span class="s2">&quot;rgb_array&quot;</span><span class="p">],</span> <span class="s2">&quot;render_fps&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_nodes</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">feature_points</span><span class="p">,</span> <span class="n">node_positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">self_loops</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_node_type</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_initial_state</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ordered_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="p">[],</span> <span class="n">min_nodes</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">distance_metric</span><span class="o">=</span><span class="s1">&#39;sqeuclidean&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize Mech gym environment</span>

<span class="sd">        Args:</span>
<span class="sd">            max_nodes (int): Maximum number of nodes (joints) in the linkage </span>
<span class="sd">            bound (float): Bounds of the designs space [-bound, bound]</span>
<span class="sd">            resolution (int): Resolution of the scaffold nodes</span>
<span class="sd">            sample_points (int): Number of points that describe the node trajectories</span>
<span class="sd">            feature_points (int): Number of points that describe the node features for GNN</span>
<span class="sd">            node_positions (list/Nd.array, optional):  Shape: (n, 2) [x, y]. Defaults to None.</span>
<span class="sd">            edges (list/Nd.Array, optional): Shape: (e, 2) [id0, id1]. Defaults to None.</span>
<span class="sd">            goal (list/Nd.Array, optional): Shape: (2, T) Goal Trajectory. Defaults to None.</span>
<span class="sd">            normalize (bool, optional): Normalize the coupler trajectory with respect to the goal trajectory. Defaults to True.</span>
<span class="sd">            self_loops (bool, optional): Include self loops in adjaecency matrix for GNN. Defaults to False.</span>
<span class="sd">            use_node_type (bool, optional): Include binary indicator for GNN. Defaults to False.</span>
<span class="sd">            seed (int, optional): Seed for the gym environment. Defaults to None.</span>
<span class="sd">            fixed_initial_state (bool, optional): When reset is called, whether the original linkage stays the same or random valid linkage is sampled. Defaults to False.</span>
<span class="sd">            ordered_distance (bool, optional): Whether the points in the trajectory should be considered ordered. Defaults to False.</span>
<span class="sd">            constraints (list, optional): ([body constraints, coupler constraints]  [[xmin, ymin, xmax, ymax], [xmin, ymin, xmax, ymax]]). Defaults to [].</span>
<span class="sd">            min_nodes (int, optional): Minimum number of nodes in the graph for a terminal action to be valid. Defaults to 5.</span>
<span class="sd">            debug (bool, optional): Enables some extra print statements. Defaults to False.</span>
<span class="sd">            distance_metric (str, optional): Check scipy.spatial.distance.cdist for various options. Defaults to &#39;sqeuclidean&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Mech</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        
        <span class="c1">## Random Seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng_seed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="c1">#np.random.seed(seed=seed)</span>
        
        <span class="c1">## Keep same initial node and edges for training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed_initial_state</span> <span class="o">=</span> <span class="n">fixed_initial_state</span> 
        
        <span class="c1">## Design is terminal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_terminal</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="c1">## Initialize Scaffold Nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="o">=</span> <span class="n">bound</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">bound</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">resolution</span><span class="p">)</span>
        <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">ii</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">jj</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>

        <span class="c1">## Environment Hyper parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaffold_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">sample_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_points</span> <span class="o">=</span> <span class="n">feature_points</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_points</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">=</span> <span class="n">max_nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_nodes</span> <span class="o">=</span> <span class="n">min_nodes</span> 
        
        <span class="c1">## GCN hyper parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="n">normalize</span> <span class="c1">## not used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">self_loops</span> <span class="o">=</span> <span class="n">self_loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_node_type</span> <span class="o">=</span> <span class="n">use_node_type</span> <span class="c1">## not used</span>

        <span class="c1">## GYM Action Space and Observation Space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_combinations</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">max_nodes</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_term_actions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_combinations</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># ncr(n, 2) | r^2 | {0, 1}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term_actions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_combinations</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># ncr(n, 2) | r^2 | {0, 1}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_term_actions</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">term_actions</span>  <span class="c1">#tuple(product(self.node_combinations, range(self.resolution**2), [0, 1])) # ncr(n, 2) | r^2 | {0, 1}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_actions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actions_hash</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_actions</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_term_actions_keys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">actions_hash</span><span class="p">[</span><span class="n">action</span><span class="p">]</span> <span class="k">for</span> <span class="n">action</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_term_actions</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">term_actions_keys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">actions_hash</span><span class="p">[</span><span class="n">action</span><span class="p">]</span> <span class="k">for</span> <span class="n">action</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_actions</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">valid_node_comb</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="o">+</span><span class="mi">1</span><span class="p">)}</span>
        <span class="c1"># self.actions = np.vstack([action_node.flatten(), action_pos.flatten()]).T</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">action_space</span> <span class="o">=</span> <span class="n">spaces</span><span class="o">.</span><span class="n">Discrete</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">))</span> <span class="c1">#self.node_combinations.shape[0]*self.resolution**2)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">bound</span>
        
        <span class="n">shape_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">feature_points</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">use_node_type</span><span class="p">))</span>
        <span class="n">shape_adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">shape_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span>
        <span class="n">shape_action_mask</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observation_space</span> <span class="o">=</span> <span class="n">spaces</span><span class="o">.</span><span class="n">Box</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">[</span><span class="n">shape_x</span><span class="o">+</span><span class="n">shape_adj</span><span class="o">+</span><span class="n">shape_mask</span><span class="o">+</span><span class="n">shape_action_mask</span><span class="p">])</span> 

        <span class="c1">## Coupler Goal </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">goal</span> <span class="o">=</span> <span class="n">goal</span>
        <span class="k">if</span> <span class="n">goal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">goal</span> <span class="o">=</span> <span class="n">goal</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">goal_scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">goal_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_metric</span> <span class="o">=</span> <span class="n">distance_metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ordered</span> <span class="o">=</span> <span class="n">ordered_distance</span>

        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">)</span>
        <span class="n">circle</span> <span class="o">=</span> <span class="n">normalize_curve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)]),</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">goal_scale</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">goal_loc</span><span class="p">)</span> <span class="c1">#Shift and scale to goal size</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">sample_points</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">goal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R_circle</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="n">circle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordered</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_metric</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">2.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">R_point</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordered</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_metric</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">2.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># self.R_circle, _, _, _ = new_dist(goal, circle)</span>
        <span class="c1"># self.R_point, _, _, _ = new_dist(goal, point)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">goal_tol</span> <span class="o">=</span> <span class="mf">1e-6</span> <span class="c1">## Hyperparameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalid_penalty</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">total_dist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cycles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reward</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1">## Design Constraints </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span> <span class="o">=</span> <span class="n">constraints</span> <span class="c1"># [body_const, coupler_const]</span>
        
        <span class="c1">## Node Type </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Input node is fixed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Fixed node</span>

        <span class="c1">### Not fixed</span>
        <span class="c1">## Mechanism Components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">node_positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># edges = np.array([[0, 1], [0, 2]])</span>
            <span class="c1"># node_positions = np.array([[1.0, 0.7], [0.9, 0.7], [0.7, 0.8]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_valid_env</span><span class="p">()</span>
            <span class="n">node_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">node_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_positions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1">## Initialize Paths</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_paths</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">best_designs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_masks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># action_mask = self._get_action_mask()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">))</span> <span class="c1">#action_mask</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">init_args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;node_positions&quot;</span><span class="p">:</span> <span class="n">node_positions</span><span class="p">,</span> 
                          <span class="s2">&quot;edges&quot;</span><span class="p">:</span>          <span class="n">edges</span><span class="p">,}</span> 
                        <span class="c1">#   &quot;prev_mask&quot;:      action_mask}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resets</span> <span class="o">=</span> <span class="mi">0</span>
        
<div class="viewcode-block" id="Mech.seed"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.seed">[docs]</a>    <span class="k">def</span> <span class="nf">seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the seed for gym env</span>

<span class="sd">        Args:</span>
<span class="sd">            seed (int, optional): seed used for gym env. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: the seed value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng_seed</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING!!!! You tried reset the random number for the environment.&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To overide the seed apply the following: </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> 
                      <span class="s2">&quot;env.rng_seed = seed </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="p">,</span>
                      <span class="s2">&quot;env.rng = RandomState(MT19937(SeedSequence(seed))) </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng_seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng_seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">RandomState</span><span class="p">(</span><span class="n">MT19937</span><span class="p">(</span><span class="n">SeedSequence</span><span class="p">(</span><span class="n">seed</span><span class="p">)))</span> 
        
        <span class="k">return</span> <span class="n">seed</span></div>
                        
<div class="viewcode-block" id="Mech.clear_best_desings"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.clear_best_desings">[docs]</a>    <span class="k">def</span> <span class="nf">clear_best_desings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears self.best_designs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_designs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">return</span></div>
        
    <span class="c1"># @timebudget</span>
    <span class="k">def</span> <span class="nf">_get_action_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finds all valid actions of the current environment state. NOTE: resuses previous masks if found in current episode</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nd.Array: Binary vector of valid actions Shape: (num_actions, )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        
        <span class="c1">## Reset all non-terminal actions to invalid if last action</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">non_term_actions_keys</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
        
        <span class="n">node_combinations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_node_comb</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">node_combinations</span><span class="p">:</span>
            <span class="c1">## Only if valid scaffold nodes not explored</span>
            <span class="k">if</span> <span class="n">comb</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_masks</span><span class="p">:</span>
                <span class="c1">## Get valid scaffold node ids</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edge_mask</span><span class="p">(</span><span class="n">comb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">comb</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                
                <span class="c1">## Cache for future designs</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edge_masks</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid</span>
            
            <span class="c1">## Update actions_mask</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaffold_ids</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_masks</span><span class="p">[</span><span class="n">comb</span><span class="p">]]:</span>
                <span class="c1">## If no constraints on coupler or body positions</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">:</span>
                     <span class="c1">## Check if scaffold node is in constraint TODO: this is wrong since it is trajectory and node position...</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_nodes</span><span class="p">):</span>
                            <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">c</span>
                            <span class="n">scaffold_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">v</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">scaffold_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">v</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">actions_hash</span><span class="p">[(</span><span class="n">comb</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">)]]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">scaffold_x</span> <span class="o">&gt;</span> <span class="n">x_min</span> <span class="ow">and</span> 
                                                                                    <span class="n">scaffold_x</span> <span class="o">&lt;</span> <span class="n">x_max</span> <span class="ow">and</span>
                                                                                    <span class="n">scaffold_y</span> <span class="o">&gt;</span> <span class="n">y_min</span> <span class="ow">and</span> 
                                                                                    <span class="n">scaffold_y</span> <span class="o">&lt;</span> <span class="n">y_max</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">## Max number of actions</span>
                    <span class="c1"># if n &lt; self.max_nodes-1:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">actions_hash</span><span class="p">[(</span><span class="n">comb</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]]</span> <span class="o">=</span> <span class="mi">1</span>
                    
                    <span class="c1">## Min number of actions</span>
                    <span class="c1"># if n &gt; self.min_nodes:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">actions_hash</span><span class="p">[(</span><span class="n">comb</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1">## </span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">term_actions_keys</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">non_term_actions_keys</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span> 
    
<div class="viewcode-block" id="Mech.apply_random_action"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.apply_random_action">[docs]</a>    <span class="k">def</span> <span class="nf">apply_random_action</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Applies a random valid action to the current environment</span>

<span class="sd">        Returns:</span>
<span class="sd">            (Nd.Array, float, bool, dict): Observation, Reward, Done, Info</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">action_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_action_mask</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">action_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_observation</span><span class="p">()</span>
            <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span> 

            <span class="k">return</span> <span class="n">obs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_penalty</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="p">{}</span> 
            
        <span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_actions</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">action_mask</span><span class="o">/</span><span class="n">action_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">action</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="Mech.reset"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the environment to a root linkage</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nd.Array: observation of the linkage (x, adj, mask, action_mask) flattened</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">## Reset variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge_masks</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">))</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_terminal</span> <span class="o">=</span> <span class="kc">False</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">resets</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1">## Get root node design</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed_initial_state</span><span class="p">:</span>
            <span class="n">node_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_args</span><span class="p">[</span><span class="s1">&#39;node_positions&#39;</span><span class="p">]</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_args</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span>

            <span class="n">n</span> <span class="o">=</span> <span class="n">node_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_positions</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_paths</span><span class="p">()</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_valid_env</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_observation</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_get_fixed_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the indexes of revolute joints that are fixed</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nd.Array: indexes of fixed nodes Shape:(m, )</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_crank_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the index for the linkage connected to the motor input</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: index of crank node</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="mi">1</span> <span class="c1"># NOTE: np.argwhere(self.adj[0,:] == 1).item()</span>

    <span class="k">def</span> <span class="nf">_get_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to get the distance between two points</span>

<span class="sd">        Args:</span>
<span class="sd">            p1 (Nd.Array): Point1 Shape: (2,)</span>
<span class="sd">            p2 (Nd.Array): Point2 Shape: (2,)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Distance between p1 and p2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p1</span><span class="o">-</span><span class="n">p2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to get the angle between two points</span>

<span class="sd">        Args:</span>
<span class="sd">            p1 (Nd.Array): Point1 Shape: (2,)</span>
<span class="sd">            p2 (Nd.Array): Point2 Shape: (2,)</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Angle between vectors from origin to p1 and p2</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_crank_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to update self.paths the trajectory of the crank revolute joint</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">crank_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_crank_id</span><span class="p">()</span>
        <span class="n">edge_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">crank_id</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">start_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">crank_id</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">crank_id</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span> 
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="n">edge_length</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">start_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">1e-3</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="n">edge_length</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">start_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">1e-3</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="n">num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
        <span class="c1"># pdb.set_trace()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">crank_id</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)])</span><span class="o">*</span><span class="n">edge_length</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates self.paths with trajectories of current linkage</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize fixed node positions</span>
        <span class="n">fixed_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fixed_ids</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">fixed_ids</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">fixed_ids</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Initialize pin node positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_crank_path</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">update_paths</span><span class="p">()</span> 
    
<div class="viewcode-block" id="Mech.number_of_nodes"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.number_of_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function returns number of nodes currently in the linkage graph</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: number of nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">empty_rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">empty_rows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">empty_rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span></div>

<div class="viewcode-block" id="Mech.number_of_edges"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.number_of_edges">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function returns the number of edges that make up the current linkage graph</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: number of edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">))</span><span class="o">//</span><span class="mi">2</span></div>

<div class="viewcode-block" id="Mech.get_edges"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.get_edges">[docs]</a>    <span class="k">def</span> <span class="nf">get_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to return all the edges in the current linkage graph</span>

<span class="sd">        Args:</span>
<span class="sd">            limit (int, optional): edges between nodes bellow a particular index. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nd.Array: Array of edge index pairs Shape: (e, 2) [id0, id1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]])</span></div>

<div class="viewcode-block" id="Mech.get_edge_lengths"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.get_edge_lengths">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to return all the edge lengths</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nd.Array: Lengths of each edge Shape: (e, )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">()</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],])</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_dist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">lengths</span></div>

<div class="viewcode-block" id="Mech.update_paths"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.update_paths">[docs]</a>    <span class="k">def</span> <span class="nf">update_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unknown_joints</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update self.paths</span>

<span class="sd">        Args:</span>
<span class="sd">            unknown_joints (list, optional): node indexes that are not known or want to be calculated. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">unknown_joints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">known_joints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">known_joints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#(np.argwhere(self.adj[0,:] == 1).item()) #TODO: Fix this</span>
            <span class="n">unknown_joints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">^</span> <span class="nb">set</span><span class="p">(</span><span class="n">known_joints</span><span class="p">))</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unknown_joints</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
            <span class="n">known_joints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">^</span> <span class="nb">set</span><span class="p">(</span><span class="n">unknown_joints</span><span class="p">))</span>


        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">^</span> <span class="nb">set</span><span class="p">(</span><span class="n">known_joints</span><span class="p">))</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unknown_joints</span><span class="p">[:]:</span>
                
                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">known_joints</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>


                    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">known_joints</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">known_joints</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>

                    <span class="c1"># Update paths</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">symbolic_kinematics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],:,:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">inds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
                    
                    <span class="n">unknown_joints</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">known_joints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span></div>
        
        
<div class="viewcode-block" id="Mech.add_node"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add node to the linkage graph</span>

<span class="sd">        Args:</span>
<span class="sd">            node_pos (Nd.Array): initial position of revolute joint Shape: (2, )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_pos</span></div>

<div class="viewcode-block" id="Mech.add_edge"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id0</span><span class="p">,</span> <span class="n">id1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add edge to linkage graph</span>

<span class="sd">        Args:</span>
<span class="sd">            id0 (int): index of node 0</span>
<span class="sd">            id1 (int): index of node 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">id0</span><span class="p">,</span> <span class="n">id1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">id1</span><span class="p">,</span> <span class="n">id0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Mech.update_fixed_paths"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.update_fixed_paths">[docs]</a>    <span class="k">def</span> <span class="nf">update_fixed_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_node_pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update self.paths for fixed revolute joints (DEPRECATED)</span>

<span class="sd">        Args:</span>
<span class="sd">            fixed_node_pos (Nd.Array): Vector of initial position of fixed nodes Shape: (n, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fixed_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fixed_ids</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">fixed_ids</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fixed_node_pos</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_crank_path</span><span class="p">()</span>

        <span class="c1"># Update rest of mechanism</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_paths</span><span class="p">()</span></div>

<div class="viewcode-block" id="Mech.coupler_traj"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.coupler_traj">[docs]</a>    <span class="k">def</span> <span class="nf">coupler_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the coupler node trajectory</span>

<span class="sd">        Args:</span>
<span class="sd">            normalize (bool, optional): Normalized curve. Defaults to True.</span>
<span class="sd">            scale (float, optional): scaling factor. Defaults to None.</span>
<span class="sd">            shift (Nd.Array, optional): x,y shift for all points. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nd.Array: coupler trajectory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="c1"># inds = np.linspace(0, self.T-1, self.test_samples).astype(int)</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span> <span class="k">return</span> <span class="n">normalize_curve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="Mech.paper_plotting"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.paper_plotting">[docs]</a>    <span class="k">def</span> <span class="nf">paper_plotting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">show_goal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_coupler</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_obj</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function for plotting figures used in paper</span>

<span class="sd">        Args:</span>
<span class="sd">            show (bool, optional): show the plot. Defaults to False.</span>
<span class="sd">            show_goal (bool, optional): plot the goal on figure. Defaults to True.</span>
<span class="sd">            show_coupler (bool, optional): plot the coupler curve on figure. Defaults to True.</span>
<span class="sd">            show_obj (bool, optional): add objective value of linkage to figure. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Matplotlib.fig: the figure object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">8.5</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
        <span class="n">coupler_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span>
        
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;k.&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span><span class="p">:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_masks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_masks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;go&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_masks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_masks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;rx&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="c1">## Plot Links and Joints</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span> 
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;0.7&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">path_effects</span><span class="o">=</span><span class="p">[</span><span class="n">pe</span><span class="o">.</span><span class="n">Stroke</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">foreground</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">),</span> <span class="n">pe</span><span class="o">.</span><span class="n">Normal</span><span class="p">()])</span> 
            <span class="c1"># plt.plot(self.paths[e, 0, 0],self.paths[e,1, 0], &#39;r.&#39;, label=&quot;joints&quot;)</span>
        
        <span class="c1">## Plot special joints    </span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;fixed joint&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">path_effects</span><span class="o">=</span><span class="p">[</span><span class="n">pe</span><span class="o">.</span><span class="n">Stroke</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">foreground</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">),</span> <span class="n">pe</span><span class="o">.</span><span class="n">Normal</span><span class="p">()])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;magenta&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;motor joint&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">path_effects</span><span class="o">=</span><span class="p">[</span><span class="n">pe</span><span class="o">.</span><span class="n">Stroke</span><span class="p">(</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">foreground</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">),</span> <span class="n">pe</span><span class="o">.</span><span class="n">Normal</span><span class="p">()])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;lime&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;crank joint&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

        <span class="c1">## Plot moveable revolute joints</span>
        <span class="n">fixed_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fixed_ids</span><span class="p">()</span>
        <span class="n">non_fixed_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fixed_ids</span><span class="p">)</span> <span class="o">^</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">coupler_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
        <span class="c1"># for n in non_fixed_ids[1:]:</span>
        <span class="c1">#     ax1.plot(self.paths[n, 0, :], self.paths[n,1, :], &#39;b-&#39;, label=&quot;pin path&quot;, ms=4)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">non_fixed_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">non_fixed_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;pin joints&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>

        <span class="c1">## Plot Coupler Path </span>
        <span class="k">if</span> <span class="n">show_coupler</span><span class="p">:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">coupler_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">coupler_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,:],</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;coupler&quot;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># ax1.plot(self.paths[coupler_idx, 0, 0],self.paths[coupler_idx, 1, 0], &#39;yo&#39;, label=&quot;coupler joint&quot;, markersize=15)</span>

        <span class="c1">## Plot Shifted Goal</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">coupler_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">std</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">coupler_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="n">goal</span> <span class="o">=</span> <span class="p">(</span><span class="n">normalize_curve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">)</span><span class="o">*</span><span class="n">std</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_goal</span><span class="p">:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">goal</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">goal</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span> <span class="s1">&#39;y-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        
        <span class="c1">## Plot constraints    </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">:</span>
            <span class="c1"># plt.axhline(y=0, color=&#39;red&#39;, linestyle=&#39;--&#39;, lw=5)</span>

            <span class="n">body_constraints</span><span class="p">,</span> <span class="n">coupler_constraints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">body_constraints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">body_constraints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">body_constraints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">body_constraints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">body_constraints</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> 
                     <span class="p">[</span><span class="n">body_constraints</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">body_constraints</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">body_constraints</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">body_constraints</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">body_constraints</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="s1">&#39;r-.&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">coupler_constraints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coupler_constraints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coupler_constraints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coupler_constraints</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coupler_constraints</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> 
                     <span class="p">[</span><span class="n">coupler_constraints</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">coupler_constraints</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">coupler_constraints</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">coupler_constraints</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">coupler_constraints</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="s1">&#39;g-.&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_axis_off</span><span class="p">()</span>
        
        <span class="c1">## Add Objective score to figure</span>
        <span class="k">if</span> <span class="n">show_obj</span><span class="p">:</span>
            <span class="n">traj_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupler_traj</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">goal_scale</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">goal_loc</span><span class="p">)</span> 

            <span class="c1"># total_dist = distance(goal, self.paths[coupler_idx, :, :], ordered=self.ordered, distance_metric=self.distance_metric).sum()*(np.pi*2./self.T)</span>
            <span class="n">total_dist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">,</span> <span class="n">traj_norm</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ordered</span><span class="p">,</span> <span class="n">distance_metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_metric</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">2.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="c1"># pdb.set_trace()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.size&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">40</span>
            <span class="n">text_box</span> <span class="o">=</span> <span class="n">AnchoredText</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;obj=</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">total_dist</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">borderpad</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">)</span>
            <span class="c1"># text_box = AnchoredText(f&quot;obj_MICP={round(total_dist2, 2)}, obj_GCPN={round(total_dist, 2)}&quot;, frameon=False, pad=0.0, borderpad=-1.0, loc=&#39;lower right&#39;)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">text_box</span><span class="o">.</span><span class="n">patch</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

            <span class="n">ax1</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">text_box</span><span class="p">)</span>


        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">1.7</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

    
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            
        <span class="k">return</span> <span class="n">fig</span></div>
    
<div class="viewcode-block" id="Mech.coords_to_pix"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.coords_to_pix">[docs]</a>    <span class="k">def</span> <span class="nf">coords_to_pix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function for self.render converting coordinates to pixels</span>

<span class="sd">        Args:</span>
<span class="sd">            x (Nd.Array): coordinates Shape: (2, n)</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nd.Array: pixel locations Shape: (2, n)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen_width</span> <span class="o">/</span> <span class="mf">2.0</span></div>
    
<div class="viewcode-block" id="Mech.render"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;human&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Render the linkage being generated</span>

<span class="sd">        Args:</span>
<span class="sd">            mode (str, optional): visualization mode. Defaults to &quot;human&quot;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            DependencyNotInstalled: needs pygame</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: successful</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pygame</span>
            <span class="kn">from</span> <span class="nn">pygame</span> <span class="kn">import</span> <span class="n">gfxdraw</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DependencyNotInstalled</span><span class="p">(</span>
                <span class="s2">&quot;pygame is not installed, run `pip install gym[classic_control]`&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">screen_width</span> <span class="o">=</span> <span class="mi">600</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen_height</span> <span class="o">=</span> <span class="mi">600</span>

        <span class="n">design_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound</span> <span class="o">*</span> <span class="mf">5.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen_width</span><span class="o">/</span> <span class="n">design_width</span> 


        <span class="bp">self</span><span class="o">.</span><span class="n">screen</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># TODO: Fix this</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># TODO: Fix me</span>
        

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">screen</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">screen_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen_height</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clock</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">surf</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">screen_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen_height</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surf</span><span class="o">.</span><span class="n">fill</span><span class="p">((</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
        
        <span class="n">path_pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_to_pix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        
        <span class="c1">## Draw Links</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">():</span>
            <span class="n">gfxdraw</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf</span><span class="p">,</span> <span class="n">path_pix</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">path_pix</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> 
                                    <span class="n">path_pix</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">path_pix</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        
        <span class="n">rad</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="c1">## Draw Motor</span>
        <span class="n">gfxdraw</span><span class="o">.</span><span class="n">filled_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf</span><span class="p">,</span> <span class="n">path_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">path_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">rad</span><span class="p">,</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">])</span>
        
        <span class="c1">## Draw Crank Node</span>
        <span class="n">gfxdraw</span><span class="o">.</span><span class="n">filled_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf</span><span class="p">,</span> <span class="n">path_pix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">path_pix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">rad</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        
        <span class="c1">## Draw Fixed Node</span>
        <span class="n">gfxdraw</span><span class="o">.</span><span class="n">filled_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf</span><span class="p">,</span> <span class="n">path_pix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">path_pix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">rad</span><span class="p">,</span> <span class="p">[</span><span class="mi">160</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">160</span><span class="p">])</span>
        
        <span class="c1">## Draw Other Nodes</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="n">gfxdraw</span><span class="o">.</span><span class="n">filled_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf</span><span class="p">,</span> <span class="n">path_pix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">path_pix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">rad</span><span class="p">,</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        
        <span class="c1">## Draw Coupler Traj</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">gfxdraw</span><span class="o">.</span><span class="n">filled_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf</span><span class="p">,</span> <span class="n">path_pix</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">],</span> <span class="n">path_pix</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">],</span> <span class="n">rad</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">std</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="c1"># pdb.set_trace()</span>
        <span class="n">goal</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="o">*</span><span class="n">std</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">goal_pix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_to_pix</span><span class="p">(</span><span class="n">goal</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1">## Draw Goal Traj</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
            <span class="n">gfxdraw</span><span class="o">.</span><span class="n">filled_circle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf</span><span class="p">,</span> <span class="n">goal_pix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">],</span> <span class="n">goal_pix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">i</span><span class="p">],</span> <span class="n">rad</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        

        <span class="bp">self</span><span class="o">.</span><span class="n">surf</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surf</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;human&quot;</span><span class="p">:</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">pump</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clock</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;render_fps&quot;</span><span class="p">])</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;rgb_array&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">surfarray</span><span class="o">.</span><span class="n">pixels3d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="p">)),</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Mech.plot_graph"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.plot_graph">[docs]</a>    <span class="k">def</span> <span class="nf">plot_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot_paths</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_coupler</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coupler_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to visualize linkage graph</span>

<span class="sd">        Args:</span>
<span class="sd">            plot_paths (bool, optional): plot revolute joint trajectories. Defaults to False.</span>
<span class="sd">            plot_coupler (bool, optional): plot coupler joint trajectory. Defaults to True.</span>
<span class="sd">            filename (str, optional): filename to save figure. Defaults to None.</span>
<span class="sd">            coupler_idx (int, optional): index of coupler index or other node that you want to be known as the coupler. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Matplotlib.fig: figure </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">## Get coupler index</span>
        <span class="k">if</span> <span class="n">coupler_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="n">coupler_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span>
        
        <span class="c1">## Initialize figure    </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        
        <span class="c1">## Plot Edges</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">(</span><span class="n">coupler_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span> 
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">e</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;k-&#39;</span><span class="p">)</span> 
            <span class="c1"># plt.plot(self.paths[e, 0, 0],self.paths[e,1, 0], &#39;r.&#39;, label=&quot;joints&quot;)</span>
        
        <span class="c1">## Plot motor and fixed node</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;r^&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;fixed joints&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;m^&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;motor joints&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="c1">## Plot revolute joints</span>
        <span class="n">fixed_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_fixed_ids</span><span class="p">()</span>
        <span class="n">non_fixed_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">fixed_ids</span><span class="p">)</span> <span class="o">^</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">coupler_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">non_fixed_ids</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">non_fixed_ids</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;pin joints&quot;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

        <span class="c1">## Plot joint trajectories</span>
        <span class="k">if</span> <span class="n">plot_paths</span><span class="p">:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:</span><span class="n">coupler_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:</span><span class="n">coupler_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,:],</span> <span class="s1">&#39;b.&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="c1">## Highlight coupler trajectory</span>
        <span class="k">if</span> <span class="n">plot_coupler</span><span class="p">:</span>
            <span class="c1"># n = self.number_of_nodes()-1</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">coupler_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">coupler_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;yo&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;coupler joint&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">coupler_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">coupler_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,:],</span> <span class="s1">&#39;y-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;coupler&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


        <span class="c1">## Figure Formating</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper center&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">),</span>
            <span class="n">fancybox</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1"># ax1 = plt.gca()</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;State Visualization&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">])</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        <span class="c1">## Plot goal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span> <span class="s1">&#39;r.&#39;</span><span class="p">,</span> <span class="n">ms</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">coupler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupler_traj</span><span class="p">()</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coupler</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">coupler</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span> <span class="s1">&#39;y.&#39;</span><span class="p">)</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">])</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_length</span><span class="p">])</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

        
        <span class="c1">## Plot constraints</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="s1">&#39;b--&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">):</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span> <span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1">## Save figure</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
            <span class="k">if</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">():</span> 
                <span class="n">out</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()))</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="Mech.is_valid"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.is_valid">[docs]</a>    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks that linkage graph is valid</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: linkage graph is valid</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span></div>
            
    
    <span class="c1"># @timebudget</span>
<div class="viewcode-block" id="Mech.get_edge_mask"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.get_edge_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_edge_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id0</span><span class="p">,</span> <span class="n">id1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valid scaffold node locations for adding to Assur 0DOF linkage to node0 and node1</span>

<span class="sd">        Args:</span>
<span class="sd">            id0 (int): index of node 0</span>
<span class="sd">            id1 (int): index of node 1</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nd.Array: valid scaffold nodes for adding to linkage graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">## Get nodei and nodej trajectories</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">id0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="c1"># 2xsteps</span>
        <span class="n">xj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">id1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="n">l_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="n">xj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># (1, steps)</span>

        <span class="n">l_ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># [1,2] - [121, 2] -&gt; (121, 1)</span>
        <span class="n">l_jk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">xj</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># [1,2] - [121, 2] -&gt; (121, 1)</span>

        <span class="c1">## Triangle inequality between node i and j trajectories</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">l_ik</span><span class="o">+</span><span class="n">l_jk</span> <span class="o">&gt;</span> <span class="n">l_ij</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> 
                                        <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">l_ik</span><span class="o">+</span><span class="n">l_ij</span> <span class="o">&gt;</span> <span class="n">l_jk</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>  
                                        <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">l_jk</span><span class="o">+</span><span class="n">l_ij</span> <span class="o">&gt;</span> <span class="n">l_ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">valid</span> <span class="c1">#np.ones_like(valid)</span></div>

    
<div class="viewcode-block" id="Mech.satisfy_constraints"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.satisfy_constraints">[docs]</a>    <span class="k">def</span> <span class="nf">satisfy_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
        <span class="sd">&quot;&quot;&quot;Checks if linkage graph satisfies the constraints</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: satifies</span>
<span class="sd">        &quot;&quot;&quot;</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bounding_box</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">):</span>
            <span class="c1">## Get body and couple index</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">())</span>
                
                <span class="c1">## If non-terminal and coupler constraints break</span>
                <span class="k">if</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span>
            
            <span class="c1">## Check that iniital state inside bounding box </span>
            <span class="c1"># TODO: this is wrong, it should consider the whole trajectory</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bounding_box</span><span class="p">:</span>
                <span class="n">valid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span>
            
            <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">1</span><span class="p">,:])</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">node</span><span class="p">,</span><span class="mi">1</span><span class="p">,:])</span>
            
            <span class="n">valid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">xmin</span><span class="o">&gt;</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                                <span class="n">xmax</span><span class="o">&lt;</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
                                <span class="n">ymin</span><span class="o">&gt;</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
                                <span class="n">ymax</span><span class="o">&lt;</span><span class="n">bounding_box</span><span class="p">[</span><span class="mi">3</span><span class="p">]]))</span>
                
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">valid</span><span class="p">)</span></div>
        
    
<div class="viewcode-block" id="Mech.get_distance"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.get_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Distance between the coupler trajectory and the goal</span>

<span class="sd">        Args:</span>
<span class="sd">            scale (float, optional): scaling factor for coupler trajectory. Defaults to None.</span>
<span class="sd">            shift (Nd.Array, optional): shifting vector for coupler trajectory. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">## Dist</span>
        <span class="n">traj_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coupler_traj</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span> 

        <span class="n">total_dist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">,</span> <span class="n">traj_norm</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ordered</span><span class="p">,</span> <span class="n">distance_metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_metric</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">2.</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">total_dist</span></div>

    <span class="k">def</span> <span class="nf">_get_reward</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reward for linkage graph</span>

<span class="sd">        Returns:</span>
<span class="sd">            (float, bool): reward, success</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">cycles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_cycles</span><span class="p">()</span>

        <span class="c1">## Not Valid</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_penalty</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward</span><span class="p">,</span> <span class="kc">False</span>
        
        <span class="c1">## Fails Constraints</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">satisfy_constraints</span><span class="p">():</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">total_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_penalty</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward</span><span class="p">,</span> <span class="kc">False</span>

        <span class="c1">## No goal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>             
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[Warning] _get_reward(): No goal was added&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="kc">False</span>
        
        <span class="c1">## Invalid design</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycles</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_penalty</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward</span><span class="p">,</span> <span class="kc">False</span>
        
        <span class="c1">## get distance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">goal_scale</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">goal_loc</span><span class="p">)</span>
        
        <span class="c1">## Normalize distance w.r.t circle </span>
        <span class="n">norm_distance_reward</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">R_circle</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">total_dist</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">R_circle</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0</span><span class="p">)</span> <span class="c1"># 0-1</span>
        
        <span class="c1">## set reward</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reward</span> <span class="o">=</span> <span class="n">norm_distance_reward</span> <span class="c1">#max(-self.total_dist, -9.9) #(cycle_weight*cycle_reward + (1.-cycle_weight)*norm_distance_reward)*10.0</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reward</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_dist</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal_tol</span><span class="p">)</span> 
        

    <span class="k">def</span> <span class="nf">_get_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;linkage graph information</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: various information that might be useful</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">## Only return info if terminal linkage design</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
            <span class="n">n_active</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_active_nodes</span><span class="p">()</span>
            
            <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;number_of_nodes&#39;</span><span class="p">:</span> <span class="n">n</span><span class="p">,</span>
                    <span class="s1">&#39;number_of_active_nodes&#39;</span><span class="p">:</span> <span class="n">n_active</span><span class="p">,</span> 
                    <span class="s1">&#39;max_nodes&#39;</span><span class="p">:</span>       <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">,</span>
                    <span class="s1">&#39;resolution&#39;</span><span class="p">:</span>      <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span><span class="p">,</span>
                    <span class="s1">&#39;bound&#39;</span><span class="p">:</span>           <span class="bp">self</span><span class="o">.</span><span class="n">bound</span><span class="p">,</span>
                    <span class="s1">&#39;feature_points&#39;</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">feature_points</span><span class="p">,</span>
                    <span class="s1">&#39;sample_points&#39;</span><span class="p">:</span>   <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                    <span class="s1">&#39;number_of_edges&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(),</span>
                    <span class="s1">&#39;node_positions&#39;</span><span class="p">:</span>  <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span>
                    <span class="s1">&#39;edges&#39;</span><span class="p">:</span>           <span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">(),</span>
                    <span class="s1">&#39;valid&#39;</span><span class="p">:</span>           <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(),</span>
                    <span class="s1">&#39;goal&#39;</span><span class="p">:</span>            <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">,</span>
                    <span class="s1">&#39;coupler&#39;</span><span class="p">:</span>         <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span>
                    <span class="s1">&#39;reward&#39;</span><span class="p">:</span>          <span class="bp">self</span><span class="o">.</span><span class="n">reward</span><span class="p">,</span> <span class="c1">## This includes information that is biased about desired behavior</span>
                    <span class="s1">&#39;cycles&#39;</span><span class="p">:</span>          <span class="bp">self</span><span class="o">.</span><span class="n">cycles</span><span class="p">,</span>
                    <span class="s1">&#39;distance&#39;</span><span class="p">:</span>        <span class="bp">self</span><span class="o">.</span><span class="n">total_dist</span><span class="p">,</span> <span class="c1">## This is the actual metric of comparison</span>
                    <span class="p">}</span>
            
            <span class="k">return</span> <span class="n">info</span> <span class="c1">#info</span>
        <span class="k">return</span> <span class="p">{}</span>
    

    <span class="k">def</span> <span class="nf">_remove_action</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function that removes previous action</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[:,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="k">assert</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>


<div class="viewcode-block" id="Mech.dfs"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.dfs">[docs]</a>    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">known_joints</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function for depth first search</span>

<span class="sd">        Args:</span>
<span class="sd">            visited (list): visited nodes</span>
<span class="sd">            edges (set): set of edges</span>
<span class="sd">            node (int): node index</span>
<span class="sd">            known_joints (list): known joint trajectories</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="n">neighbours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">known_joints</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">known_joints</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]][:</span><span class="mi">2</span><span class="p">]</span>
            <span class="c1"># print(node, neighbours)</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbours</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">neighbours</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">,</span> <span class="n">known_joints</span><span class="p">)</span></div>
                
<div class="viewcode-block" id="Mech.get_active_nodes"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.get_active_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">get_active_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function to get all known nodes that contribute to coupler trajectory</span>

<span class="sd">        Returns:</span>
<span class="sd">            (list, set): node indexes that are used for coupler FK, edges that are useful for linkage graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">## All nodes</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>

        <span class="c1">## Initialize variables</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">known_joints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="c1">## Recursively trace from coupler to root nodes </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">known_joints</span><span class="p">)</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">active_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">visited</span>
        
        <span class="k">return</span> <span class="n">active_nodes</span><span class="p">,</span> <span class="n">edges</span></div>
    
<div class="viewcode-block" id="Mech.number_of_active_nodes"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.number_of_active_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_active_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function returns number of active nodes</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: number of active nodes in linkage graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_active_nodes</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="Mech.prune"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.prune">[docs]</a>    <span class="k">def</span> <span class="nf">prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prune linkage graph of unnecessary revolute joints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">## Get active nodes and edges</span>
        <span class="n">active_nodes</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_nodes</span><span class="p">()</span>
        <span class="n">active_nodes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_nodes</span><span class="p">)</span>
        
        <span class="c1">## update edge list</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span><span class="o">+</span> <span class="p">[[</span><span class="n">active_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">active_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>
        
        <span class="c1">## get all paths of active nodes</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">active_nodes</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1">## Reset linkage graph paths and adj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span>
        
        <span class="c1">## Update with only active nodes and edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">paths</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span> 
     
        <span class="c1">## reinitialize linkage graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_paths</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="Mech.active_cycles"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.active_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">active_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all the active loops in the linkage graph  </span>

<span class="sd">        Returns:</span>
<span class="sd">            list: all cycles in linkage graph NOTE: this includes cycles with 3 nodes which are not valid loops</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1">## Get active nodes and edges</span>
        <span class="n">active_nodes</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_nodes</span><span class="p">()</span>
        <span class="n">active_nodes</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_nodes</span><span class="p">)</span>
        
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span><span class="o">+</span> <span class="p">[[</span><span class="n">active_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">active_nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">e</span><span class="p">)[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">])</span>
        
        <span class="c1">## initialize nx graph</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        
        <span class="c1">## Minimum cycle basis</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">minimum_cycle_basis</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="Mech.number_of_cycles"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.number_of_cycles">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of active linkage graph loops</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: number of active linkage graph loops NOTE: this excludes loops of 3 nodes (also known as triads as they are not useful)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_cycles</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">cycles</span><span class="p">)</span></div>
        

<div class="viewcode-block" id="Mech.update_best_designs"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.update_best_designs">[docs]</a>    <span class="k">def</span> <span class="nf">update_best_designs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update set of best designs of various linakge graph topologies</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">## Prune linkage graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prune</span><span class="p">()</span>
        
        <span class="c1">## If linkage graph topology not accounted for yet        </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cycles</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_designs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_designs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cycles</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">()),</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reward</span><span class="p">))</span>
                <span class="k">return</span> 
            
            <span class="c1">## If linkage graph is better than current topology </span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_dist</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_designs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cycles</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_designs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cycles</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_edges</span><span class="p">()),</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reward</span><span class="p">))</span>
                <span class="k">return</span> </div>

<div class="viewcode-block" id="Mech.step"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update linkage graph with new action</span>

<span class="sd">        Args:</span>
<span class="sd">            action (int): index of action </span>

<span class="sd">        Returns:</span>
<span class="sd">            (Nd.Array, float, bool, dict): Observation, Reward, Done, Info</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">action</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prev_mask</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;selected an action that was deemed invalid&quot;</span><span class="p">)</span>
        <span class="c1">## Get action from index</span>
        <span class="p">(</span><span class="n">node_id0</span><span class="p">,</span> <span class="n">node_id1</span><span class="p">),</span> <span class="n">scaffold_id</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actions</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">action</span><span class="p">)]</span>
        
        <span class="c1">## Is terminal action</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_terminal</span> <span class="o">=</span> <span class="n">done</span>


        <span class="c1">## If Action is the same as previous Terminate Episode</span>
        <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span><span class="p">:</span> 
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: (Action) Same Action was selected again. Note that this is considered invalid&quot;</span><span class="p">)</span>
                
            <span class="n">obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_observation</span><span class="p">()</span>
            <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span> 

            <span class="k">return</span> <span class="n">obs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_penalty</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="p">{}</span> 

        
        <span class="c1">## Check if node selection is valid </span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node_id0</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="ow">or</span> <span class="n">node_id1</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: (Nodes) Same Action was selected again. Note that this is considered invalid&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_observation</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_penalty</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="p">{}</span>

        <span class="c1">## Valid node add to linkage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">scaffold_id</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">new_node_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node_id0</span><span class="p">,</span> <span class="n">new_node_id</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">node_id1</span><span class="p">,</span> <span class="n">new_node_id</span><span class="p">)</span>

        <span class="c1">## Update Paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">new_node_id</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">symbolic_kinematics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">node_id0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">node_id1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="n">new_node_id</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1">## If Kinematics Valid Check</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: (Kinematics) Action led to kinematically infeasible design.&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_action</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_observation</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_penalty</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="p">{}</span>
        
        <span class="c1">## Check if finished design </span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: (Terminal) Failed to finish design in valid number of steps.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_observation</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">invalid_penalty</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="p">{}</span>

        <span class="c1">## Get reward</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">done</span><span class="p">:</span>
            <span class="n">reward</span><span class="p">,</span> <span class="n">solved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_reward</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">solved</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found exact solution...stop search&quot;</span><span class="p">)</span>
            <span class="c1">## Save all good designs during the search</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_best_designs</span><span class="p">()</span>
    
        <span class="bp">self</span><span class="o">.</span><span class="n">previous_action</span> <span class="o">=</span> <span class="n">action</span>
        
        <span class="n">obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_observation</span><span class="p">()</span>
        <span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info</span><span class="p">()</span> 
        
        <span class="c1"># Return Status</span>
        <span class="k">return</span> <span class="n">obs</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">info</span> </div>
    
<div class="viewcode-block" id="Mech.get_observation"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.get_observation">[docs]</a>    <span class="k">def</span> <span class="nf">get_observation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Observation of current linkage state</span>

<span class="sd">        Returns:</span>
<span class="sd">            Nd.Array: [X ((Node_features)*max_nodes), adj (max_nodes*max_nodes), mask (max_nodes), action_mask (number_of_actions)] flattened</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">## Revolution joint positons </span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_points</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="c1">## NOTE: use_node_type DEPRECATED</span>
        <span class="c1"># if self.use_node_type:</span>
        <span class="c1">#     x = [[self.paths[i, 0, 0], self.paths[i, 1, 0], 1] if (i == self.number_of_nodes()-1 and self.is_terminal) else </span>
        <span class="c1">#         [self.paths[i, 0, 0], self.paths[i, 1, 0], 0] for i in range(self.max_nodes)] </span>
        <span class="c1">#     obs.append(np.asarray(sum(x, [])).astype(&#39;float32&#39;))</span>

        <span class="c1"># else:</span>
        <span class="c1">#     # x = [[self.paths[i, 0, 0], self.paths[i, 1, 0]] for i in range(self.max_nodes)]</span>
        
        <span class="c1">## Node features</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
        <span class="n">obs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        
        <span class="c1">## Adjacency Matrix</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">self_loops</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            
        <span class="n">obs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">adj</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="c1">## Node Mask </span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_nodes</span><span class="p">()</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">obs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">))</span>

        <span class="c1">## Node Action Mask</span>
        <span class="n">action_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_action_mask</span><span class="p">())</span>
        <span class="n">obs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">action_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">))</span>
        
        <span class="n">obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="Mech.random_4_bar"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.random_4_bar">[docs]</a>    <span class="k">def</span> <span class="nf">random_4_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">bar_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Random valid n bar linakge NOTE: not really N_bar, based on edges input</span>

<span class="sd">        Args:</span>
<span class="sd">            edges (Nd.Array): set of edges Shape: (e, 2)</span>
<span class="sd">            n (int): number of revolute joints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pos_ind</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># s = l = 1 </span>
        <span class="c1"># p = q = 0</span>
        
        <span class="c1"># ## Random Crank-Rocker N-Bar</span>
        <span class="c1"># while s+l &gt; p+q:</span>
        <span class="n">node_pos_ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">pos_ind</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">node_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">node_pos_ind</span><span class="p">,:]</span>
        
        <span class="n">lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">-</span> <span class="n">node_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span><span class="o">-</span> <span class="n">node_pos</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[</span><span class="mi">3</span><span class="p">,:]</span><span class="o">-</span> <span class="n">node_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">node_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span><span class="o">-</span> <span class="n">node_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">if</span> <span class="n">bar_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1">## Crank Rocker</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">[</span><span class="n">lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">3</span><span class="p">]]):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">lengths</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                <span class="c1"># print(&quot;not valid&quot;)</span>
                <span class="k">return</span> <span class="kc">False</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">base_type</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">if</span> <span class="n">bar_type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1">## Double Rocker</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">]]):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">lengths</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">lengths</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="c1"># print(&quot;not valid&quot;)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># print(&quot;valid double rocker&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">base_type</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
            <span class="c1"># s = np.linalg.norm(node_pos[0]-node_pos[1])</span>
            <span class="c1"># q = np.linalg.norm(node_pos[0]-node_pos[2])</span>
            <span class="c1"># l = np.linalg.norm(node_pos[1]-node_pos[3])</span>
            <span class="c1"># p = np.linalg.norm(node_pos[2]-node_pos[3])</span>
        
        
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">node_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">edges</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">edges</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_paths</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Mech.get_valid_env"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.get_valid_env">[docs]</a>    <span class="k">def</span> <span class="nf">get_valid_env</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bar_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate random valid linkage graph</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: is valid</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">## Basic 4-bar configuration</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_4_bar</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">bar_type</span><span class="p">)</span>
        
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Step 2 check validity </span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">satisfy_constraints</span><span class="p">()</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="c1"># If not valid save data</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_4_bar</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">bar_type</span><span class="p">)</span>


        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid</span><span class="p">()</span></div>
        
        
<div class="viewcode-block" id="Mech.close"><a class="viewcode-back" href="../../../mech.html#linkage_gym.envs.Mech.Mech.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close environment</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>




<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pyvirtualdisplay</span>

    <span class="n">env</span> <span class="o">=</span> <span class="n">Mech</span><span class="p">(</span><span class="n">max_nodes</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">sample_points</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">feature_points</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">20</span><span class="p">]),</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">_display</span> <span class="o">=</span> <span class="n">pyvirtualdisplay</span><span class="o">.</span><span class="n">Display</span><span class="p">(</span><span class="n">visible</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>  <span class="c1"># use False with Xvfb</span>
                                    <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">600</span><span class="p">))</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">_display</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
        <span class="n">env</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">apply_random_action</span><span class="p">()</span>
    <span class="n">_display</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
    <span class="c1"># # pdb.set_trace()</span>
    <span class="c1"># filenames = [&#39;jansen_traj&#39;, &#39;klann_traj&#39;, &#39;strider_traj&#39;, &#39;trot_traj&#39;] #[&#39;jansen_traj&#39;, &#39;klann_traj&#39;] #, &#39;strider_traj&#39;, &#39;trot_traj&#39;] #, &#39;infinity_200&#39;, &#39;loopfolium_150&#39;, &#39;quadrifoilium_200&#39;, &#39;trifolium_100&#39;, &#39;double_loopfolium_200&#39;]</span>
    <span class="c1"># sample_points = 20</span>
    
    <span class="c1"># for goal_filename in filenames:</span>
    <span class="c1">#     for _ in range(1):</span>
    <span class="c1">#         # goal_filename = &quot;fake_jansen_goal&quot;</span>
    <span class="c1">#         tb_log_dir = f&quot;./logs/{goal_filename}&quot;</span>

    <span class="c1">#         if not os.path.isdir(tb_log_dir):</span>
    <span class="c1">#             os.mkdir(tb_log_dir)</span>

    <span class="c1">#         goal_curve = pickle.load(open(f&#39;saved_footpaths/{goal_filename}.pkl&#39;, &#39;rb&#39;))</span>
    <span class="c1">#         idx = np.round(np.linspace(0, goal_curve.shape[1] - 1, sample_points)).astype(int)</span>
    <span class="c1">#         goal = normalize_curve(goal_curve[:,idx])</span>

    <span class="c1">#         env_kwargs = {&quot;max_nodes&quot;:10, </span>
    <span class="c1">#                       &quot;bound&quot;:1., </span>
    <span class="c1">#                       &quot;resolution&quot;:11, </span>
    <span class="c1">#                       &quot;sample_points&quot;:sample_points, </span>
    <span class="c1">#                       &quot;goal&quot;:goal, </span>
    <span class="c1">#                       &quot;normalize&quot;:True, </span>
    <span class="c1">#                       &quot;seed&quot;: 2, </span>
    <span class="c1">#                       &quot;fixed_initial_state&quot;: False}</span>
    <span class="c1">#         env = Mech(**env_kwargs)</span>
    <span class="c1">#         # env = make_vec_env(Mech, n_envs=4, env_kwargs=env_kwargs) # TODO</span>
    <span class="c1">#         # pdb.set_trace()</span>
            
    <span class="c1">#         gnn_kwargs = {&quot;hidden_channels&quot;:64, </span>
    <span class="c1">#                       &quot;out_channels&quot;:64, </span>
    <span class="c1">#                       &quot;normalize&quot;:False, </span>
    <span class="c1">#                       &quot;batch_normalization&quot;:False, </span>
    <span class="c1">#                       &quot;lin&quot;:True, </span>
    <span class="c1">#                       &quot;add_loop&quot;:False}</span>
    <span class="c1">#         dqn_arch = [64, 256, 1024, 4096]</span>
    <span class="c1">#         ppo_arch = [64, dict(vf=[32], pi=[256, 1024, 4096])]</span>
    <span class="c1">#         # env = make_vec_env(lambda: env, n_envs=1)</span>
    <span class="c1">#         policy_kwargs = dict(</span>
    <span class="c1">#             features_extractor_class=GNN,</span>
    <span class="c1">#             features_extractor_kwargs=gnn_kwargs,</span>
    <span class="c1">#             net_arch=dqn_arch,</span>
    <span class="c1">#         )</span>
    <span class="c1">#         model = CustomDQN(policy=CustomDQNPolicy,</span>
    <span class="c1">#                 env=env,</span>
    <span class="c1">#                 learning_rate=linear_schedule(1e-3),</span>
    <span class="c1">#                 buffer_size=100000,  # 1e6</span>
    <span class="c1">#                 learning_starts=500,</span>
    <span class="c1">#                 batch_size=512,</span>
    <span class="c1">#                 tau=1.0, # the soft update coefficient (Polyak update, between 0 and 1)</span>
    <span class="c1">#                 gamma=0.99,</span>
    <span class="c1">#                 train_freq=(1000, &quot;step&quot;),</span>
    <span class="c1">#                 gradient_steps=1,</span>
    <span class="c1">#                 replay_buffer_class=None,</span>
    <span class="c1">#                 replay_buffer_kwargs=None,</span>
    <span class="c1">#                 optimize_memory_usage=False,</span>
    <span class="c1">#                 target_update_interval=10000,</span>
    <span class="c1">#                 exploration_fraction=0.8, # percent of learning that includes exploration</span>
    <span class="c1">#                 exploration_initial_eps=1.0, # Initial random search</span>
    <span class="c1">#                 exploration_final_eps=0.05, # final stochasticity</span>
    <span class="c1">#                 max_grad_norm=10.,</span>
    <span class="c1">#                 tensorboard_log=tb_log_dir,</span>
    <span class="c1">#                 create_eval_env=False,</span>
    <span class="c1">#                 policy_kwargs=policy_kwargs,</span>
    <span class="c1">#                 verbose=0,</span>
    <span class="c1">#                 seed=None,</span>
    <span class="c1">#                 device=&quot;cuda:1&quot;,</span>
    <span class="c1">#                 _init_setup_model=True)</span>
    <span class="c1">#         # model = DQN(policy=&#39;MultiInputPolicy&#39;,</span>
    <span class="c1">#         #         env=env,</span>
    <span class="c1">#         #         learning_rate=linear_schedule(1e-4),</span>
    <span class="c1">#         #         buffer_size=100000,  # 1e6</span>
    <span class="c1">#         #         learning_starts=5000,</span>
    <span class="c1">#         #         batch_size=1024,</span>
    <span class="c1">#         #         tau=1.0,</span>
    <span class="c1">#         #         gamma=0.99,</span>
    <span class="c1">#         #         train_freq=4,</span>
    <span class="c1">#         #         gradient_steps=1,</span>
    <span class="c1">#         #         replay_buffer_class=None,</span>
    <span class="c1">#         #         replay_buffer_kwargs=None,</span>
    <span class="c1">#         #         optimize_memory_usage=False,</span>
    <span class="c1">#         #         target_update_interval=2500,</span>
    <span class="c1">#         #         exploration_fraction=0.8, # percent of learning that includes exploration</span>
    <span class="c1">#         #         exploration_initial_eps=1.0, # Initial random search</span>
    <span class="c1">#         #         exploration_final_eps=0.05, # final stochasticity</span>
    <span class="c1">#         #         max_grad_norm=10.,</span>
    <span class="c1">#         #         tensorboard_log=tb_log_dir,</span>
    <span class="c1">#         #         create_eval_env=False,</span>
    <span class="c1">#         #         policy_kwargs=policy_kwargs,</span>
    <span class="c1">#         #         verbose=0,</span>
    <span class="c1">#         #         seed=None,</span>
    <span class="c1">#         #         device=&quot;cuda:2&quot;,</span>
    <span class="c1">#         #         _init_setup_model=True)</span>
    <span class="c1">#         # model = PPO(policy=CustomActorCriticPolicy, </span>
    <span class="c1">#         #             env=env, </span>
    <span class="c1">#         #             learning_rate=1e-4, </span>
    <span class="c1">#         #             n_steps=1000, </span>
    <span class="c1">#         #             batch_size=500, </span>
    <span class="c1">#         #             n_epochs=1, </span>
    <span class="c1">#         #             gamma=0.99, </span>
    <span class="c1">#         #             gae_lambda=0.95,</span>
    <span class="c1">#         #             clip_range=0.2, </span>
    <span class="c1">#         #             clip_range_vf=None, </span>
    <span class="c1">#         #             # normalize_advantage=True, </span>
    <span class="c1">#         #             ent_coef=0.01,</span>
    <span class="c1">#         #             vf_coef=0.5, </span>
    <span class="c1">#         #             max_grad_norm=0.5, </span>
    <span class="c1">#         #             use_sde=False, </span>
    <span class="c1">#         #             sde_sample_freq=-1,</span>
    <span class="c1">#         #             target_kl=None, </span>
    <span class="c1">#         #             tensorboard_log=tb_log_dir, </span>
    <span class="c1">#         #             create_eval_env=False, </span>
    <span class="c1">#         #             policy_kwargs=policy_kwargs,</span>
    <span class="c1">#         #             verbose=1, </span>
    <span class="c1">#         #             seed=None, </span>
    <span class="c1">#         #             device=&quot;cuda:1&quot;, </span>
    <span class="c1">#         #             _init_setup_model=True)</span>
    <span class="c1">#         # model = A2C(policy=CustomActorCriticPolicy,</span>
    <span class="c1">#         #     env=env,</span>
    <span class="c1">#         #     learning_rate=linear_schedule(1e-3),</span>
    <span class="c1">#         #     n_steps=5,</span>
    <span class="c1">#         #     gamma=0.99,</span>
    <span class="c1">#         #     gae_lambda=1.0,</span>
    <span class="c1">#         #     ent_coef=0.01,</span>
    <span class="c1">#         #     vf_coef=0.5,</span>
    <span class="c1">#         #     max_grad_norm=0.5,</span>
    <span class="c1">#         #     rms_prop_eps=1e-5,</span>
    <span class="c1">#         #     use_rms_prop=True,</span>
    <span class="c1">#         #     use_sde=False,</span>
    <span class="c1">#         #     sde_sample_freq=-1,</span>
    <span class="c1">#         #     normalize_advantage=False,</span>
    <span class="c1">#         #     tensorboard_log=tb_log_dir,</span>
    <span class="c1">#         #     create_eval_env=False,</span>
    <span class="c1">#         #     policy_kwargs=policy_kwargs,</span>
    <span class="c1">#         #     verbose=1,</span>
    <span class="c1">#         #     seed=0,</span>
    <span class="c1">#         #     device=&quot;cuda:0&quot;,</span>
    <span class="c1">#         #     _init_setup_model=True)</span>
    <span class="c1">#         # model.load(&quot;dqn_mech_v3&quot;)</span>

    <span class="c1">#         model.learn(20000)</span>
    <span class="c1">#         model_filename = uniquify(f&quot;./{type(model).__name__}_mech_v4_{goal_filename}.zip&quot;)</span>
    <span class="c1">#         model.save(model_filename)</span>
            
    <span class="c1">#         if type(model).__name__ == &quot;PPO&quot;: best_designs = env.get_attr(&#39;best_designs&#39;)</span>
    <span class="c1">#         else: best_designs = env.best_designs</span>
            
    <span class="c1">#         if best_designs:</span>
    <span class="c1">#             pickle.dump(best_designs, open(uniquify(f&#39;best_designs_{goal_filename}.pkl&#39;), &#39;wb&#39;))</span>

    <span class="c1"># # model = DQN.load(f&quot;./dqn_mech_v3_{goal_filename}&quot;)</span>

    <span class="c1"># # obs = env.reset()</span>
    <span class="c1"># # for _ in range(10):</span>
    <span class="c1"># #     action, _states = model.predict(obs, deterministic=False)</span>
    <span class="c1"># #     obs, reward, done, info = env.step(action)</span>
    <span class="c1"># #     env.render(show=True)</span>
    <span class="c1"># #     if done:</span>
    <span class="c1"># #         obs = env.reset()</span>
    <span class="c1"># # pdb.set_trace()</span>

    <span class="c1"># # env.init(node_positions=node_pos, edges=initial_edges, steps=50)</span>
    <span class="c1"># # pdb.set_trace()</span>
    <span class="c1"># # Step 2 check validity </span>
    <span class="c1"># # while not env.is_valid():</span>
    <span class="c1"># #     # If not valid save data</span>
    <span class="c1"># #     node_pos_ind = np.random.choice(pos_ind, size=4, replace=False)</span>
    <span class="c1"># #     node_pos = pos[node_pos_ind,:]</span>
    <span class="c1"># #     env = Mech()</span>
    <span class="c1"># #     env.init(node_positions=node_pos, edges=initial_edges, steps=50)</span>

    <span class="c1"># # try:</span>
    <span class="c1"># # except Exception as e:</span>
    <span class="c1"># #     print(e)</span>
    <span class="c1"># #     pdb.set_trace()</span>
    <span class="c1"># # env.render(show=True)</span>

    <span class="c1"># # Tests</span>
    <span class="c1"># # Import random graph</span>
    <span class="c1"># # filename = &#39;saved_graphs/six_bar/six-bar1.pkl&#39;</span>
    <span class="c1"># # g = pickle.load(open(filename, &#39;rb&#39;))</span>
    <span class="c1"># # graph = Mech(node_positions=g.joints[:,:,0].T, edges=g.lam, steps=50)</span>
    <span class="c1"># # graph.update_fixed_paths(fixed_node_pos=np.array([[-1., 0.], graph.paths[3,:,0]-1]))</span>
    <span class="c1"># # graph.add_node(np.array([2., -2.]))</span>
    <span class="c1"># # graph.add_edge(graph.number_of_nodes()-1, 3)</span>
    <span class="c1"># # graph.add_edge(graph.number_of_nodes()-1, 2)</span>
    <span class="c1"># # graph.update_paths()</span>
    <span class="c1"># # graph.sample_workspace(5, 2)</span>
    <span class="c1"># # if graph.is_valid():</span>
    <span class="c1"># #     graph.plot_graph(plot_paths=True, filename=&quot;testing_mech.png&quot;)</span>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Mitchell Fogelson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>